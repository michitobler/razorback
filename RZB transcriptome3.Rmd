---
title: "Razorback Sucker Transcriptomics"
output: html_notebook
---

# Dependencies

```{r message=FALSE}
library(DESeq2)
library(tidyverse)
library(VennDetail)
library(adegenet)
library(limma)
library(edgeR)
library(splines)
library(RColorBrewer)
library(ggplot2)
library(data.table)
library(ggsankey)
library(networkD3)
library(dplyr)
library(tibble)
library(WGCNA)
library(flashClust)
library(cluster)
library(circlize)
```

# For Parallelization
```{r}
library(doParallel)
registerDoParallel(cores=23)
```


# Import and Format Data

```{r}
### Load annotations
annot <- read.csv("blastx.go.results.human.csv")
ann.unique <- annot[!duplicated(annot[,c("queryid", "swissprotid")]),]
ann.ref <- ann.unique[!ann.unique$GeneID %in% as.vector(rownames(data)),]

### Load the sample information
coldata<-read.csv("coldata2.csv",row.names = 1)

### Load the gene count data
data<-read.csv("gene_count_matrix_01July2022.csv",row.names = 1)

#Drop tanks with issues
data$Tank_10<-NULL
data$Tank_77<-NULL
data$Tank_15<-NULL

### Remove genes with no expression
keep <- rowSums(cpm(data)>=1) >= 18
data_keep <- data[keep,]

### Create a new DESeq object
dds <- DESeqDataSetFromMatrix(countData = data_keep,
                              colData = coldata,
                              design = ~ group)

#Data transformation
vsd<-vst(dds)
```



# Single model with simple contrasts
```{r}
# Subset data so analyses can be run on all times together (this is just for internal control)
all.samps <- coldata
all.n <- row.names(all.samps)
all <- data_keep[,which(colnames(data_keep) %in% all.n)]
dim(all)


# Group samples by temperature
time.all = all.samps$time2
temps.all = all.samps$temp2
group.all = all.samps$group
fam.all = all.samps$rbs

# Generate data frame for each time with sample names and temperature
all.samples = data.frame(cbind(colnames(all)), as.character(group.all))
colnames(all.samples) = c("tank","group")

# Create a DGEList object to hold the dataset
all.dge = DGEList(counts = all, group = all.samples$group)


# Calculate normalized factors based on raw library sizes
all.dge = calcNormFactors(all.dge)

# Create a design matrix (because the datasets are already split in three by tissue, the only predictor is site)
sample.design.all <- model.matrix(~0 + group.all + fam.all)


colnames(sample.design.all) <- sub("group.all", "", colnames(sample.design.all))
colnames(sample.design.all) <- sub("fam.all", "", colnames(sample.design.all))

# Estimate common dispersion and tagwise dispersion
all.dge <- estimateDisp(all.dge, sample.design.all)


# Given tagwise dispersion and a design matrix, glmFIT fits the negative binomial GLM for each tag. 
# Will then produce a DGEGLM object with new components. 
sample.fit.all <- glmFit(all.dge, sample.design.all)

# Construct contrast matrix of comparisons (compare populations in each tissue)
all.contrast.20.18 <- makeContrasts(
  RBZ = (g1.20+g2.20+g3.20)/3 - (g1.18+g2.18+g3.18)/3,
  levels = sample.design.all
  )

all.contrast.20.16 <- makeContrasts(
  RBZ = (g1.20+g2.20+g3.20)/3 - (g1.16+g2.16+g3.16)/3,
  levels = sample.design.all
  )


# Use the DGEGLM object to perform likelihood ratio test based on the contrast matrix of comparisons
all_lrt_temp20.18 = glmLRT(sample.fit.all, contrast = all.contrast.20.18[,"RBZ"])
all_lrt_temp20.16 = glmLRT(sample.fit.all, contrast = all.contrast.20.16[,"RBZ"])


# Summary of differential expression that was up, down or not significant in each comparison
summary(decideTestsDGE(all_lrt_temp20.18, adjust.method = "BH", p.value = 0.05))
summary(decideTestsDGE(all_lrt_temp20.16, adjust.method = "BH", p.value = 0.05))
```

```{r}
# Extract the results of the LRT for each gene to see which ones were differential expressed. 
all.18.table <- all_lrt_temp20.18$table
all.18.table$FDR <- p.adjust(all.18.table$PValue, method = "BH")
all.18.table$GeneID <- rownames(all.18.table)
colnames(all.18.table) <- paste("all_18", colnames(all.18.table), sep = "_")

all.16.table <- all_lrt_temp20.16$table
all.16.table$FDR <- p.adjust(all.16.table$PValue, method = "BH")
all.16.table$GeneID <- rownames(all.16.table)
colnames(all.16.table) <- paste("all_16", colnames(all.16.table), sep = "_")

# Combine all the results tables above together into the same df
all.tables.comb <- as.data.frame(cbind(all.18.table, all.16.table))

# Quality control: check to make sure all the rows are lined up correctly by checking if the GeneID columns all line up 
sum(which(all.tables.comb$all_18_GeneID != all.tables.comb$all_16_GeneID)) # should be zero if they match up
sum(which(all.tables.comb$all_18_GeneID != all.tables.comb$all_18_GeneID)) 


# Now let's add this table to the original df ######
composite.filtered <- as.data.frame(cbind(data_keep, all.tables.comb))

# Extracting top tags for t1 and dividing into signficantly up- or downregulated
top_all_20.18 = topTags(all_lrt_temp20.18, n = (2455 + 1365))
top_all_20.18.up = rownames(top_all_20.18[top_all_20.18$table$logFC > 0,])
top_all_20.18.dn = rownames(top_all_20.18[top_all_20.18$table$logFC < 0,])

top_all_20.16 = topTags(all_lrt_temp20.16, n = (8970 + 7857))
top_all_20.16.up = rownames(top_all_20.16[top_all_20.16$table$
                                            logFC > 0,])
top_all_20.16.dn = rownames(top_all_20.16[top_all_20.16$table$logFC < 0,])
```

## Venns

```{r}
# Upregulated candidate genes at t1
universal.all.up <- unique(c(top_all_20.18.up, top_all_20.16.up))
all.A.up <- universal.all.up %in% top_all_20.18.up
all.B.up <- universal.all.up %in% top_all_20.16.up
universal.all.up.input.df <- data.frame("temp18" = all.A.up, "temp16" = all.B.up)
head(universal.all.up.input.df)
venn.all.up.universal <- vennCounts(universal.all.up.input.df)
vennDiagram(venn.all.up.universal, main = "Upregulated Genes at Time 1", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.all.upreg <- universal.all.up[which(universal.all.up.input.df["temp18"] == T & universal.all.up.input.df["temp16"] == T )]
common.all.upreg <- data.frame(common.all.upreg)
names(common.all.upreg) <- "GeneID"
##########t1.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

```{r}
# Downregulated candidate genes at t1
universal.all.dn <- unique(c(top_all_20.18.dn, top_all_20.16.dn))
all.A.dn <- universal.all.dn %in% top_all_20.18.dn
all.B.dn <- universal.all.dn %in% top_all_20.16.dn
universal.all.dn.input.df <- data.frame("temp18" = all.A.dn, "temp16" = all.B.dn)
head(universal.all.dn.input.df)
venn.all.dn.universal <- vennCounts(universal.all.dn.input.df)
vennDiagram(venn.all.dn.universal, main = "Downregulated Genes at Time 1", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.all.dnreg <- universal.all.dn[which(universal.all.dn.input.df["temp18"] == T & universal.all.dn.input.df["temp16"] == T )]
common.all.dnreg <- data.frame(common.all.dnreg)
names(common.all.dnreg) <- "GeneID"
##########t1.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```
## Pull out annotations
### All genes in the analysis (reference)

```{r}
ann.ref.all <- ann.unique[!ann.unique$GeneID %in% as.vector(rownames(data_keep)),]
```

### T1 candidates
```{r}
ann.all.shup <- ann.unique[ann.unique$GeneID %in% as.vector(common.all.upreg$GeneID),]
ann.all.18up <- ann.unique[ann.unique$GeneID %in% as.vector(top_all_20.18.up),]
ann.all.16up <- ann.unique[ann.unique$GeneID %in% as.vector(top_all_20.16.up),]
ann.all.16up.unique <- ann.all.16up[!ann.all.16up$GeneID %in% as.vector(ann.all.shup$GeneID),]

ann.all.shdn <- ann.unique[ann.unique$GeneID %in% as.vector(common.all.dnreg$GeneID),]
ann.all.18dn <- ann.unique[ann.unique$GeneID %in% as.vector(top_all_20.18.dn),]
ann.all.16dn <- ann.unique[ann.unique$GeneID %in% as.vector(top_all_20.16.dn),]
ann.all.16dn.unique <- ann.all.16dn[!ann.all.16dn$GeneID %in% as.vector(ann.all.shdn$GeneID),]
```


### File export for enrichment analyses
```{r}
ann.ref2 <- ann.unique[!ann.unique$GeneID %in% as.vector(rownames(data_keep)),]
res.ref <- ann.ref2$swissprotid

res.all.18up <- ann.all.18up$swissprotid
res.all.16up.u <- ann.all.16up.unique$swissprotid
res.all.18dn <- ann.all.18dn$swissprotid
res.all.16dn.u <- ann.all.16dn.unique$swissprotid

n <- length(res.ref)

length(res.all.18up) <- n                      
length(res.all.16up.u) <- n
length(res.all.18dn) <- n
length(res.all.16dn.u) <- n

res.fin <- cbind(res.ref, 
                 res.all.18up, res.all.16up.u, res.all.18dn, res.all.16dn.u)

write.csv(res.fin, "annot all for GO.csv")
```


### All but within time points
```{r}
t1.contrast.20.18 <- makeContrasts(
  RBZ = g1.20 - g1.18,
  levels = sample.design.all
  )
t1.contrast.20.16 <- makeContrasts(
  RBZ = g1.20 - g1.16,
  levels = sample.design.all
  )

t2.contrast.20.18 <- makeContrasts(
  RBZ = g2.20 - g2.18,
  levels = sample.design.all
  )
t2.contrast.20.16 <- makeContrasts(
  RBZ = g2.20 - g2.16,
  levels = sample.design.all
  )

t3.contrast.20.18 <- makeContrasts(
  RBZ = g3.20 - g3.18,
  levels = sample.design.all
  )
t3.contrast.20.16 <- makeContrasts(
  RBZ = g3.20 - g3.16,
  levels = sample.design.all
  )

# Use the DGEGLM object to perform likelihood ratio test based on the contrast matrix of comparisons
t1_lrt_temp20.18 = glmLRT(sample.fit.all, contrast = t1.contrast.20.18[,"RBZ"])
t1_lrt_temp20.16 = glmLRT(sample.fit.all, contrast = t1.contrast.20.16[,"RBZ"])

t2_lrt_temp20.18 = glmLRT(sample.fit.all, contrast = t2.contrast.20.18[,"RBZ"])
t2_lrt_temp20.16 = glmLRT(sample.fit.all, contrast = t2.contrast.20.16[,"RBZ"])

t3_lrt_temp20.18 = glmLRT(sample.fit.all, contrast = t3.contrast.20.18[,"RBZ"])
t3_lrt_temp20.16 = glmLRT(sample.fit.all, contrast = t3.contrast.20.16[,"RBZ"])

summary(decideTestsDGE(t1_lrt_temp20.18, adjust.method = "BH", p.value = 0.05))
summary(decideTestsDGE(t1_lrt_temp20.16, adjust.method = "BH", p.value = 0.05))

summary(decideTestsDGE(t2_lrt_temp20.18, adjust.method = "BH", p.value = 0.05))
summary(decideTestsDGE(t2_lrt_temp20.16, adjust.method = "BH", p.value = 0.05))

summary(decideTestsDGE(t3_lrt_temp20.18, adjust.method = "BH", p.value = 0.05))
summary(decideTestsDGE(t3_lrt_temp20.16, adjust.method = "BH", p.value = 0.05))
```


## Pulling out DE genes

```{r}
# Extract the results of the LRT for each gene to see which ones were differentially expressed. This can be found in the 
# "table" element from the lrt objects. We'll also need to add a column for FDR based on the p-value given
t1.18.table <- t1_lrt_temp20.18$table
t1.18.table$FDR <- p.adjust(t1.18.table$PValue, method = "BH")
t1.18.table$GeneID <- rownames(t1.18.table)
colnames(t1.18.table) <- paste("t1_18", colnames(t1.18.table), sep = "_")

t1.16.table <- t1_lrt_temp20.16$table
t1.16.table$FDR <- p.adjust(t1.16.table$PValue, method = "BH")
t1.16.table$GeneID <- rownames(t1.16.table)
colnames(t1.16.table) <- paste("t1_16", colnames(t1.16.table), sep = "_")


t2.18.table <- t2_lrt_temp20.18$table
t2.18.table$FDR <- p.adjust(t2.18.table$PValue, method = "BH")
t2.18.table$GeneID <- rownames(t2.18.table)
colnames(t2.18.table) <- paste("t2_18", colnames(t2.18.table), sep = "_")

t2.16.table <- t2_lrt_temp20.16$table
t2.16.table$FDR <- p.adjust(t2.16.table$PValue, method = "BH")
t2.16.table$GeneID <- rownames(t2.16.table)
colnames(t2.16.table) <- paste("t2_16", colnames(t2.16.table), sep = "_")


t3.18.table <- t3_lrt_temp20.18$table
t3.18.table$FDR <- p.adjust(t3.18.table$PValue, method = "BH")
t3.18.table$GeneID <- rownames(t3.18.table)
colnames(t3.18.table) <- paste("t3_18", colnames(t3.18.table), sep = "_")

t3.16.table <- t3_lrt_temp20.16$table
t3.16.table$FDR <- p.adjust(t3.16.table$PValue, method = "BH")
t3.16.table$GeneID <- rownames(t3.16.table)
colnames(t3.16.table) <- paste("t3_16", colnames(t3.16.table), sep = "_")

# Combine all the results tables above together into the same df
all.tables <- as.data.frame(cbind(t1.18.table, t1.16.table, t2.18.table, t2.16.table, t3.18.table, t3.16.table))

# Quality control: check to make sure all the rows are lined up correctly by checking if the GeneID columns all line up 
sum(which(all.tables$t1_18_GeneID != all.tables$t1_16_GeneID)) # should be zero if they match up
sum(which(all.tables$t1_18_GeneID != all.tables$t2_18_GeneID)) 
sum(which(all.tables$t1_18_GeneID != all.tables$t2_16_GeneID))
sum(which(all.tables$t1_18_GeneID != all.tables$t3_18_GeneID))
sum(which(all.tables$t1_18_GeneID != all.tables$t3_16_GeneID))

# Now let's add this table to the original df ######
composite.filtered <- as.data.frame(cbind(data_keep, all.tables))

# Extracting top tags for t1 and dividing into signficantly up- or downregulated
top_t1_20.18 = topTags(t1_lrt_temp20.18, n = (215 + 220))
top_t1_20.18.up = rownames(top_t1_20.18[top_t1_20.18$table$logFC > 0,])
top_t1_20.18.dn = rownames(top_t1_20.18[top_t1_20.18$table$logFC < 0,])

top_t1_20.16 = topTags(t1_lrt_temp20.16, n = (2260+2456))
top_t1_20.16.up = rownames(top_t1_20.16[top_t1_20.16$table$logFC > 0,])
top_t1_20.16.dn = rownames(top_t1_20.16[top_t1_20.16$table$logFC < 0,])

# Extracting top tags for t2 and dividing into signficantly up- or downregulated
top_t2_20.18 = topTags(t2_lrt_temp20.18, n = (1188 + 585))
top_t2_20.18.up = rownames(top_t2_20.18[top_t2_20.18$table$logFC > 0,])
top_t2_20.18.dn = rownames(top_t2_20.18[top_t2_20.18$table$logFC < 0,])

top_t2_20.16 = topTags(t2_lrt_temp20.16, n = (1444 + 1829))
top_t2_20.16.up = rownames(top_t2_20.16[top_t2_20.16$table$logFC > 0,])
top_t2_20.16.dn = rownames(top_t2_20.16[top_t2_20.16$table$logFC < 0,])

# Extracting top tags for t3 and dividing into signficantly up- or downregulated
top_t3_20.18 = topTags(t3_lrt_temp20.18, n = (2425 + 1123))
top_t3_20.18.up = rownames(top_t3_20.18[top_t3_20.18$table$logFC > 0,])
top_t3_20.18.dn = rownames(top_t3_20.18[top_t3_20.18$table$logFC < 0,])

top_t3_20.16 = topTags(t3_lrt_temp20.16, n = (10417 + 8278))
top_t3_20.16.up = rownames(top_t3_20.16[top_t3_20.16$table$logFC > 0,])
top_t3_20.16.dn = rownames(top_t3_20.16[top_t3_20.16$table$logFC < 0,])
```

## Venns

### Time 1

```{r}
# Upregulated candidate genes at t1
universal.t1.up <- unique(c(top_t1_20.18.up, top_t1_20.16.up))
t1.A.up <- universal.t1.up %in% top_t1_20.18.up
t1.B.up <- universal.t1.up %in% top_t1_20.16.up
universal.t1.up.input.df <- data.frame("temp18" = t1.A.up, "temp16" = t1.B.up)
head(universal.t1.up.input.df)
venn.t1.up.universal <- vennCounts(universal.t1.up.input.df)
vennDiagram(venn.t1.up.universal, main = "Upregulated Genes at Time 1", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t1.upreg <- universal.t1.up[which(universal.t1.up.input.df["temp18"] == T & universal.t1.up.input.df["temp16"] == T )]
common.t1.upreg <- data.frame(common.t1.upreg)
names(common.t1.upreg) <- "GeneID"
##########t1.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

```{r}
# Downregulated candidate genes at t1
universal.t1.dn <- unique(c(top_t1_20.18.dn, top_t1_20.16.dn))
t1.A.dn <- universal.t1.dn %in% top_t1_20.18.dn
t1.B.dn <- universal.t1.dn %in% top_t1_20.16.dn
universal.t1.dn.input.df <- data.frame("temp18" = t1.A.dn, "temp16" = t1.B.dn)
head(universal.t1.dn.input.df)
venn.t1.dn.universal <- vennCounts(universal.t1.dn.input.df)
vennDiagram(venn.t1.dn.universal, main = "Downregulated Genes at Time 1", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t1.dnreg <- universal.t1.dn[which(universal.t1.dn.input.df["temp18"] == T & universal.t1.dn.input.df["temp16"] == T )]
common.t1.dnreg <- data.frame(common.t1.dnreg)
names(common.t1.dnreg) <- "GeneID"
##########t1.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

### Time 2

```{r}
# Upregulated candidate genes at t2
universal.t2.up <- unique(c(top_t2_20.18.up, top_t2_20.16.up))
t2.A.up <- universal.t2.up %in% top_t2_20.18.up
t2.B.up <- universal.t2.up %in% top_t2_20.16.up
universal.t2.up.input.df <- data.frame("temp18" = t2.A.up, "temp16" = t2.B.up)
head(universal.t2.up.input.df)
venn.t2.up.universal <- vennCounts(universal.t2.up.input.df)
vennDiagram(venn.t2.up.universal, main = "Upregulated Genes at Time 2", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t2.upreg <- universal.t2.up[which(universal.t2.up.input.df["temp18"] == T & universal.t2.up.input.df["temp16"] == T )]
common.t2.upreg <- data.frame(common.t2.upreg)
names(common.t2.upreg) <- "GeneID"
##########t2.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

```{r}
# Downregulated candidate genes at t2
universal.t2.dn <- unique(c(top_t2_20.18.dn, top_t2_20.16.dn))
t2.A.dn <- universal.t2.dn %in% top_t2_20.18.dn
t2.B.dn <- universal.t2.dn %in% top_t2_20.16.dn
universal.t2.dn.input.df <- data.frame("temp18" = t2.A.dn, "temp16" = t2.B.dn)
head(universal.t2.dn.input.df)
venn.t2.dn.universal <- vennCounts(universal.t2.dn.input.df)
vennDiagram(venn.t2.dn.universal, main = "Downregulated Genes at Time 2", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t2.dnreg <- universal.t2.dn[which(universal.t2.dn.input.df["temp18"] == T & universal.t2.dn.input.df["temp16"] == T )]
common.t2.dnreg <- data.frame(common.t2.dnreg)
names(common.t2.dnreg) <- "GeneID"
##########t2.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

### Time 3

```{r}
# Upregulated candidate genes at t3
universal.t3.up <- unique(c(top_t3_20.18.up, top_t3_20.16.up))
t3.A.up <- universal.t3.up %in% top_t3_20.18.up
t3.B.up <- universal.t3.up %in% top_t3_20.16.up
universal.t3.up.input.df <- data.frame("temp18" = t3.A.up, "temp16" = t3.B.up)
head(universal.t3.up.input.df)
venn.t3.up.universal <- vennCounts(universal.t3.up.input.df)
vennDiagram(venn.t3.up.universal, main = "Upregulated Genes at Time 3", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t3.upreg <- universal.t3.up[which(universal.t3.up.input.df["temp18"] == T & universal.t3.up.input.df["temp16"] == T )]
common.t3.upreg <- data.frame(common.t3.upreg)
names(common.t3.upreg) <- "GeneID"
##########t3.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

```{r}
# Downregulated candidate genes at t3
universal.t3.dn <- unique(c(top_t3_20.18.dn, top_t3_20.16.dn))
t3.A.dn <- universal.t3.dn %in% top_t3_20.18.dn
t3.B.dn <- universal.t3.dn %in% top_t3_20.16.dn
universal.t3.dn.input.df <- data.frame("temp18" = t3.A.dn, "temp16" = t3.B.dn)
head(universal.t3.dn.input.df)
venn.t3.dn.universal <- vennCounts(universal.t3.dn.input.df)
vennDiagram(venn.t3.dn.universal, main = "Downregulated Genes at Time 3", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t3.dnreg <- universal.t3.dn[which(universal.t3.dn.input.df["temp18"] == T & universal.t3.dn.input.df["temp16"] == T )]
common.t3.dnreg <- data.frame(common.t3.dnreg)
names(common.t3.dnreg) <- "GeneID"
##########t3.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

```{r fig.height=6, fig.width=6}
vdat <- read.csv("venndat.csv")

vdat$comp <- factor(vdat$comp, levels=c("t16", "t18", "sh"))

ggplot(vdat, aes(x=time, y=count, fill=comp))+
  geom_hline(yintercept = 0)+
  geom_bar(position = "stack", stat="identity")+
  theme_classic()+
  labs(x="Timepoint", y="Number of differentially expressed genes", fill="Group")+
  scale_fill_manual(values=c("#5DA5DA", "#FAA43A", "#4D4D4D"))+
  theme(legend.position = c(0.1, 0.9), legend.background = element_blank())
```


## Generate lists for GO enrichment analyses

### All genes in the analysis (reference)

```{r eval=FALSE, include=FALSE}
ann.ref <- ann.unique[!ann.unique$GeneID %in% as.vector(rownames(data)),]
```

### T1 candidates
```{r eval=FALSE, include=FALSE}
ann.t1.shup <- ann.unique[ann.unique$GeneID %in% as.vector(common.t1.upreg$GeneID),]
ann.t1.18up <- ann.unique[ann.unique$GeneID %in% as.vector(top_t1_20.18.up),]
ann.t1.16up <- ann.unique[ann.unique$GeneID %in% as.vector(top_t1_20.16.up),]
ann.t1.16up.unique <- ann.t1.16up[!ann.t1.16up$GeneID %in% as.vector(ann.t1.shup$GeneID),]

ann.t1.shdn <- ann.unique[ann.unique$GeneID %in% as.vector(common.t1.dnreg$GeneID),]
ann.t1.18dn <- ann.unique[ann.unique$GeneID %in% as.vector(top_t1_20.18.dn),]
ann.t1.16dn <- ann.unique[ann.unique$GeneID %in% as.vector(top_t1_20.16.dn),]
ann.t1.16dn.unique <- ann.t1.16dn[!ann.t1.16dn$GeneID %in% as.vector(ann.t1.shdn$GeneID),]
```

### T2 candidates
```{r eval=FALSE, include=FALSE}
ann.t2.shup <- ann.unique[ann.unique$GeneID %in% as.vector(common.t2.upreg$GeneID),]
ann.t2.18up <- ann.unique[ann.unique$GeneID %in% as.vector(top_t2_20.18.up),]
ann.t2.16up <- ann.unique[ann.unique$GeneID %in% as.vector(top_t2_20.16.up),]
ann.t2.16up.unique <- ann.t2.16up[!ann.t2.16up$GeneID %in% as.vector(ann.t2.shup$GeneID),]

ann.t2.shdn <- ann.unique[ann.unique$GeneID %in% as.vector(common.t2.dnreg$GeneID),]
ann.t2.18dn <- ann.unique[ann.unique$GeneID %in% as.vector(top_t2_20.18.dn),]
ann.t2.16dn <- ann.unique[ann.unique$GeneID %in% as.vector(top_t2_20.16.dn),]
ann.t2.16dn.unique <- ann.t2.16dn[!ann.t2.16dn$GeneID %in% as.vector(ann.t2.shdn$GeneID),]
```

### T3 candidates
```{r eval=FALSE, include=FALSE}
ann.t3.shup <- ann.unique[ann.unique$GeneID %in% as.vector(common.t3.upreg$GeneID),]
ann.t3.18up <- ann.unique[ann.unique$GeneID %in% as.vector(top_t3_20.18.up),]
ann.t3.16up <- ann.unique[ann.unique$GeneID %in% as.vector(top_t3_20.16.up),]
ann.t3.16up.unique <- ann.t3.16up[!ann.t3.16up$GeneID %in% as.vector(ann.t3.shup$GeneID),]

ann.t3.shdn <- ann.unique[ann.unique$GeneID %in% as.vector(common.t3.dnreg$GeneID),]
ann.t3.18dn <- ann.unique[ann.unique$GeneID %in% as.vector(top_t3_20.18.dn),]
ann.t3.16dn <- ann.unique[ann.unique$GeneID %in% as.vector(top_t3_20.16.dn),]
ann.t3.16dn.unique <- ann.t3.16dn[!ann.t3.16dn$GeneID %in% as.vector(ann.t3.shdn$GeneID),]
```

### File export for enrichment analyses
```{r eval=FALSE, include=FALSE}
res.ref <- ann.ref$swissprotid

res.t1.18up <- ann.t1.18up$swissprotid
res.t1.16up.u <- ann.t1.16up.unique$swissprotid
res.t1.18dn <- ann.t1.18dn$swissprotid
res.t1.16dn.u <- ann.t1.16dn.unique$swissprotid

res.t2.18up <- ann.t2.18up$swissprotid
res.t2.16up.u <- ann.t2.16up.unique$swissprotid
res.t2.18dn <- ann.t2.18dn$swissprotid
res.t2.16dn.u <- ann.t2.16dn.unique$swissprotid

res.t3.18up <- ann.t3.18up$swissprotid
res.t3.16up.u <- ann.t3.16up.unique$swissprotid
res.t3.18dn <- ann.t3.18dn$swissprotid
res.t3.16dn.u <- ann.t3.16dn.unique$swissprotid

n <- length(res.ref)


length(res.t1.18up) <- n                      
length(res.t1.16up.u) <- n
length(res.t1.18dn) <- n
length(res.t1.16dn.u) <- n
length(res.t2.18up) <- n
length(res.t2.16up.u) <- n
length(res.t2.18dn) <- n
length(res.t2.16dn.u) <- n
length(res.t3.18up) <- n
length(res.t3.16up.u) <- n
length(res.t3.18dn) <- n
length(res.t3.16dn.u) <- n

res.fin <- cbind(res.ref, 
                 res.t1.18up, res.t1.16up.u, res.t1.18dn, res.t1.16dn.u,
                 res.t2.18up, res.t2.16up.u, res.t2.18dn, res.t2.16dn.u,
                 res.t3.18up, res.t3.16up.u, res.t3.18dn, res.t3.16dn.u)


write.csv(res.fin, "annot for GO.csv")
```

## MDS

```{r fig.height=6, fig.width=6}
# Construct MDS plot on top 10,000 expressed transcripts 
mds <- plotMDS(all.dge, top=2500, gene.selection = "common")

mds.mt <- as.data.frame(all.dge$samples)
mds.sc <- as.data.frame(cbind(mds$x, mds$y))
names(mds.sc) <- c("mds.x", "mds.y")
mds.sc2 <- cbind(mds.mt, mds.sc)
mds.sc3 <- separate(mds.sc2, group, c('time', 'temp'))
mds.sc3$time <- str_replace(mds.sc3$time, "g", "T")
# Calculate centroid (average) position for each population
centroid = aggregate(cbind(mds.x, mds.y) ~ temp + time, data = mds.sc3, FUN = mean)
centroid$time <- str_replace(centroid$time, "g", "T")


# Add centroid coordinates to ind_coords dataframe
mds.sc4 = left_join(mds.sc3, centroid, by = c("temp"="temp", "time"="time"), suffix = c("",".cen"))



# Scatter plot axis 1 vs. 2
ggplot(data = mds.sc4, aes(x = mds.x, y = mds.y))+
  # spider segments
  geom_segment(aes(xend = mds.x.cen, yend = mds.y.cen, colour = temp), show.legend = FALSE)+
  # points
  geom_point(aes(color = temp), size = 3)+
  # centroids
  geom_label(data = centroid, aes(label = time, fill = temp), size = 4, show.legend = FALSE)+
  labs(x="MDS axis 1", y="MDS axis 2", color="Temperature")+
  scale_fill_manual(values=c("#5DA5DA", "#FAA43A", "#F15854"))+
  scale_color_manual(values=c("#5DA5DA", "#FAA43A", "#F15854"))+
  theme_classic()+
  theme(legend.position = c(0.1, 0.1), legend.background = element_blank())


```

## WGCNA

https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Consensus-RelateModsToTraits.pdf
https://bioinformaticsworkbook.org/tutorials/wgcna.html#gsc.tab=0

```{r eval=FALSE, include=FALSE}
#### DATA INPUT AND CLEANING
# important, do not omit
options(stringsAsFactors = FALSE)

# allow multi-threading within WGCNA, at present this call is necessary.
# any error here may be ignored but you may want to update WGCNA if you see one
# caution: skip this line if you run RStudio or other third-party R environments
#allowWGCNAThreads()

#Keep data that meet the filtering criteria
#Nothing removed; Nate already pre-filtered

#Trim data: Each row (i.e. transcript) must have greater than 2 counts per million (cpm) and at least 15 of the 53 samples must have counts data

#test <- cpm(data)
#test2 <- as.data.frame(rowSums(test))
#keep <- rowSums(cpm(data)>=1) >= 1

##############################Keep data that meet the filtering criteria#########################
#filtered_reads <- data[keep,]
#filtered_reads <- data_keep
#dim(data)
#dim(filtered_reads)


filtered_reads <- data_keep

# implement a variance-stabilizing transformation to counts dataset
vst2 <- varianceStabilizingTransformation(as.matrix(filtered_reads), blind = T, fitType = "parametric")

# create DGElist
y <- DGEList(counts=vst2, group=coldata$group)

# normalize library
y <- calcNormFactors(y)

# make a data frame of log counts per million
counts_per_mil <- cpm(y, normalized.lib.sizes=TRUE, log=TRUE, prior.count=1)

# transform data frame
dat_expr_0 = as.data.frame(t(counts_per_mil[,]))

# check data for excessive missing values and identification of outlier samples
gsg = goodSamplesGenes(dat_expr_0, verbose = 3)
gsg$allOK

# remove the offending genes and samples from the data
#if (!gsg$allOK)
##{
#dat_expr_0 = dat_expr_0[gsg$goodSamples, gsg$goodGenes]
#}

# check outliers - clustering by sample not by gene
# plot the sample tree: open a graphic output window of size 12 by 9 inches
sample_tree = hclust(dist(dat_expr_0), method = "average")
pdf(file = "01_rzb_clustering.pdf", width = 12, height = 9)
sizeGrWindow(12,9)
par(cex = 0.6)
par(mar = c(0,4,2,0))
plot(sample_tree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
# plot a line to show the cut
abline(h = 400, col = "red")
dev.off()

# Determine cluster under the line
clust = cutreeStatic(sample_tree, cutHeight = 400, minSize = 1)
table(clust)

rownames(dat_expr_0)
# Make predictors numeric
pred.time <- as.numeric(coldata$time) 
pred.temp <- as.numeric(coldata$temp)
pred.20 <- as.numeric(ifelse(pred.temp==20, 1, 0))
pred.18 <- as.numeric(ifelse(pred.temp==18, 1, 0))
pred.16 <- as.numeric(ifelse(pred.temp==16, 1, 0))

test <- cbind(coldata$time, pred.time)

traits <- data.frame(pred.time, pred.temp, pred.20, pred.18, pred.16)
rownames(traits) <- rownames(dat_expr_0)

# visualize how the clinical traits relate to the dendrogram
# re-cluster samples
sample_tree_2 = hclust(dist(dat_expr_0), method = "average")

# convert traits to a color representation: white means low, red means high, grey means missing entry
trait_colors = numbers2colors(traits, signed = T)

# plot the sample dendrogram and the colors underneath.
pdf(file = "02_rzb_clustering.pdf")
plotDendroAndColors(sample_tree_2, trait_colors,
                    groupLabels = names(traits),
                    main = "Dendrogram and trait heatmap")
dev.off()

#### CONSTRUCTION OF THE GENE NETWORK AND THE IDENTIFICATION OF MODULES ####-------------------------------------

# STEP-BY-STEP (as opposed to automatic) network construction and module detection

allowWGCNAThreads()

# choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))

# call the network topology analysis function
sft = pickSoftThreshold(dat_expr_0, powerVector = powers, networkType = "signed", verbose = 5)

# plot the results:
pdf(file = "03__rzb_clustering.pdf", width = 9, height = 5)
#sizeGrWindow(9, 5) # Joanna doesn't have this, if there's an issue plotting try removing this
par(mfrow = c(1, 2))
cex1 = 0.9
# scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)", ylab="Scale Free Topology Model Fit,signed R^2", type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red")

# this line corresponds to using an R^2 cut-off of h
# I picked a power of 4
abline(h=0.9,col="red")

# mean connectivity as a function of the soft-thresholding power

plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)", ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1, col="red")
dev.off()

# calculate the adjacencies, using the soft-thresholding power
softPower = 9
adjacency = adjacency(dat_expr_0, type = "signed", power = softPower)

# turn adjacency into topological overlap matrix (TOM), then calculate the corresponding dissimilarity
TOM = TOMsimilarity(adjacency, TOMType = "signed")
dissTOM = 1-TOM

# call the hierarchical clustering function on TOM dissimilarity matrix
geneTree = hclust(as.dist(dissTOM), method = "average")

# plot the resulting clustering tree (dendrogram)
pdf(file = "04_gill_gene_clustering_on_TOM-based_dissimilarity_signed_Limia.pdf", width = 12, height = 9)
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)
dev.off()

# authors: we like large modules, so we set the minimum module size relatively high
# me: decrease from 30 (what the manual used) because we had 29 differentially expressed genes total, 30 is too large, GO term for eye function may not include 30 genes
minModuleSize = 50

# module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize);
table(dynamicMods)

# now plot the module assignment under the gene dendrogram
# convert numeric labels into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)

# plot the dendrogram and colors underneath
pdf(file = "05_gill_gene_dendrogram_and_module_colors_signed_Limia.pdf", width = 8, height = 6)
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")
dev.off()


# merging of modules whose expression profiles are very similar
# calculate eigengenes
MEList = moduleEigengenes(dat_expr_0, softPower = 7, colors = dynamicColors)
MEs = MEList$eigengenes
print("MEs:")
MEs

# calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs)

# cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average")

# plot the result
pdf(file = "06_RBZ.pdf", width = 7, height = 6)
sizeGrWindow(7, 6)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")

# I chose a height cut of 0.25, corresponding to a correlation of 0.75, to merge
MEDissThres = 0.25

# plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
dev.off()

# call an automatic merging function
merge = mergeCloseModules(dat_expr_0, dynamicColors, cutHeight = MEDissThres, verbose = 3)

# the merged module colors
mergedColors = merge$colors

# eigengenes of the new merged modules:
mergedMEs = merge$newMEs

# to see what the merging did to our module colors, we plot the gene dendrogram again, with the original and merged module colors underneath
pdf(file = "07_gills_geneDendro_signed_RZB2.pdf", wi = 12, he = 9)
sizeGrWindow(12, 9)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
dev.off()

# in the subsequent analysis, we will use the merged module colors in mergedColors
# we save the relevant variables for use in subsequent parts of the tutorial
# rename to moduleColors
moduleColors = mergedColors

# construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50))
moduleLabels = match(moduleColors, colorOrder)-1
MEs = mergedMEs

# save module colors and labels for use in subsequent parts
#save(MEs, moduleLabels, moduleColors, geneTree, file = "TarCreek-gills-RNAseq-WGCNA-networkConstruction-stepByStep-Limia.RData")

#### Relating modules to external information and identifying important genes ------------------------------------------------------------------------------------------------------
# setting up the R session and loading results of previous parts

# the following setting is important, do not omit
#options(stringsAsFactors = FALSE)

# load the expression and trait data saved in the first part
#lnames = load(file = "myEnv_WGCNA_gill_part1_Limia.RData")

# the variable lnames contains the names of loaded variables
#lnames

# load network data saved in the second part
#lnames = load(file = "TarCreek-gills-RNAseq-WGCNA-networkConstruction-stepByStep-Limia.RData")
#lnames

# relating modules to external traits
# quantifying module-trait associations, identify modules that are significantly associated with the measured clinical trials

# define numbers of genes and samples
nGenes = ncol(dat_expr_0)
nSamples = nrow(dat_expr_0)

# recalculate MEs with color labels
MEs0 = moduleEigengenes(dat_expr_0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
print("Now the MEs are:")
MEs
moduleTraitCor = cor(MEs, traits, use = "p")
moduleTraitCor
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
moduleTraitPvalue

# will display correlations and their p-values
pdf(file = "08_gills_correlations_and_p_values_signed_Limia2xxx.pdf", wi = 13, he = 15)
sizeGrWindow(13,15)
textMatrix = paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3))

# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = names(traits),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module-trait relationships"))
dev.off()

# gene relationship to trait and important modules: gene significance and module membership
# define variable enviro containing the environment (cave_vs_surface) column of traits
enviro = as.data.frame(traits)
names(enviro) = "enviro"

# names (colors) of the modules
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(dat_expr_0, MEs, use = "p"))
print("geneModuleMembership:")
geneModuleMembership
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
print("MMPvalue:")
MMPvalue

names(geneModuleMembership) = paste("MM", modNames, sep="")
names(MMPvalue) = paste("p.MM", modNames, sep="")

geneTraitSignificance = as.data.frame(cor(dat_expr_0, enviro, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))

names(geneTraitSignificance) = paste("GS.", names(enviro), sep="")
names(GSPvalue) = paste("p.GS.", names(enviro), sep="")



##################################

#############


module = "magenta"
column = match(module, modNames)
moduleGenes = moduleColors==module

pdf(file = "magenta.pdf", wi = 7, he = 7)
sizeGrWindow(7, 7)
par(mfrow = c(1,1))
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for environment",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
dev.off()


############


module = "tan"
column = match(module, modNames)
moduleGenes = moduleColors==module

pdf(file = "tan.pdf", wi = 7, he = 7)
sizeGrWindow(7, 7)
par(mfrow = c(1,1))
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for environment",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
dev.off()

############


module = "brown"
column = match(module, modNames)
moduleGenes = moduleColors==module

pdf(file = "brown.pdf", wi = 7, he = 7)
sizeGrWindow(7, 7)
par(mfrow = c(1,1))
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for environment",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
dev.off()

############


module = "orange"
column = match(module, modNames)
moduleGenes = moduleColors==module

pdf(file = "orange.pdf", wi = 7, he = 7)
sizeGrWindow(7, 7)
par(mfrow = c(1,1))
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for environment",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
dev.off()

##################################
# pick out a few modules of interest here
module_df <- data.frame(gene_id = names(dat_expr_0),colors = moduleColors )

modules_of_interest = c("magenta", "tan", "brown", "orange")




```

#Annotation
```{r}
magenta.genes <- names(dat_expr_0)[moduleColors=="magenta"]
length(names(dat_expr_0)[moduleColors=="magenta"])

tan.genes <- names(dat_expr_0)[moduleColors=="tan"]
length(names(dat_expr_0)[moduleColors=="tan"])

brown.genes <- names(dat_expr_0)[moduleColors=="brown"]
length(names(dat_expr_0)[moduleColors=="brown"])

orange.genes <- names(dat_expr_0)[moduleColors=="orange"]
length(names(dat_expr_0)[moduleColors=="orange"])

ann.magenta <- ann.unique[ann.unique$GeneID %in% as.vector(magenta.genes),]
ann.tan <- ann.unique[ann.unique$GeneID %in% as.vector(tan.genes),]
ann.brown <- ann.unique[ann.unique$GeneID %in% as.vector(brown.genes),]
ann.orange <- ann.unique[ann.unique$GeneID %in% as.vector(orange.genes),]

res.ref <- ann.ref$swissprotid

res.ann.magenta <- ann.magenta$swissprotid
res.ann.tan <- ann.tan$swissprotid
res.ann.brown <- ann.brown$swissprotid
res.ann.orange <- ann.orange$swissprotid

n <- length(res.ref)

length(res.ann.magenta) <- n                      
length(res.ann.tan) <- n
length(res.ann.brown) <- n
length(res.ann.orange) <- n



res.fin.module <- cbind(res.ref, 
                 res.ann.magenta, res.ann.tan, res.ann.brown, res.ann.orange)


write.csv(res.fin.module, "annot all for GO module.csv")


```























## Shankey
https://cran.r-project.org/web/packages/ggalluvial/vignettes/ggalluvial.html

```{r eval=FALSE, include=FALSE}
all.tables2 <- tibble::rownames_to_column(all.tables, "Gene_ID")

#For each gene and time point, make categories
all.tables2$T1 <- ifelse(all.tables2$t1_18_FDR < 0.05 & all.tables2$t1_16_FDR < 0.05 & all.tables2$t1_18_logFC > 0 & all.tables2$t1_16_logFC > 0, "shared up",
                         ifelse(all.tables2$t1_18_FDR < 0.05 & all.tables2$t1_16_FDR < 0.05 & all.tables2$t1_18_logFC < 0 & all.tables2$t1_16_logFC < 0, "shared down",
                                ifelse(all.tables2$t1_18_FDR < 0.05 & all.tables2$t1_16_FDR > 0.05 & all.tables2$t1_18_logFC > 0, "18 up",
                                       ifelse(all.tables2$t1_18_FDR > 0.05 & all.tables2$t1_16_FDR < 0.05 & all.tables2$t1_16_logFC > 0, "16 up",
                                              ifelse(all.tables2$t1_18_FDR < 0.05 & all.tables2$t1_16_FDR > 0.05 & all.tables2$t1_18_logFC < 0, "18 down",
                                                     ifelse(all.tables2$t1_18_FDR > 0.05 & all.tables2$t1_16_FDR < 0.05 & all.tables2$t1_16_logFC < 0, "16 down",
                                                            "NS"))))))

all.tables2$T2 <- ifelse(all.tables2$t2_18_FDR < 0.05 & all.tables2$t2_16_FDR < 0.05 & all.tables2$t2_18_logFC > 0 & all.tables2$t2_16_logFC > 0, "shared up",
                         ifelse(all.tables2$t2_18_FDR < 0.05 & all.tables2$t2_16_FDR < 0.05 & all.tables2$t2_18_logFC < 0 & all.tables2$t2_16_logFC < 0, "shared down",
                                ifelse(all.tables2$t2_18_FDR < 0.05 & all.tables2$t2_16_FDR > 0.05 & all.tables2$t2_18_logFC > 0, "18 up",
                                       ifelse(all.tables2$t2_18_FDR > 0.05 & all.tables2$t2_16_FDR < 0.05 & all.tables2$t2_16_logFC > 0, "16 up",
                                              ifelse(all.tables2$t2_18_FDR < 0.05 & all.tables2$t2_16_FDR > 0.05 & all.tables2$t2_18_logFC < 0, "18 down",
                                                     ifelse(all.tables2$t2_18_FDR > 0.05 & all.tables2$t2_16_FDR < 0.05 & all.tables2$t2_16_logFC < 0, "16 down",
                                                            "NS"))))))

all.tables2$T3 <- ifelse(all.tables2$t3_18_FDR < 0.05 & all.tables2$t3_16_FDR < 0.05 & all.tables2$t3_18_logFC > 0 & all.tables2$t3_16_logFC > 0, "shared up",
                         ifelse(all.tables2$t3_18_FDR < 0.05 & all.tables2$t3_16_FDR < 0.05 & all.tables2$t3_18_logFC < 0 & all.tables2$t3_16_logFC < 0, "shared down",
                                ifelse(all.tables2$t3_18_FDR < 0.05 & all.tables2$t3_16_FDR > 0.05 & all.tables2$t3_18_logFC > 0, "18 up",
                                       ifelse(all.tables2$t3_18_FDR > 0.05 & all.tables2$t3_16_FDR < 0.05 & all.tables2$t3_16_logFC > 0, "16 up",
                                              ifelse(all.tables2$t3_18_FDR < 0.05 & all.tables2$t3_16_FDR > 0.05 & all.tables2$t3_18_logFC < 0, "18 down",
                                                     ifelse(all.tables2$t3_18_FDR > 0.05 & all.tables2$t3_16_FDR < 0.05 & all.tables2$t3_16_logFC < 0, "16 down",
                                                            "NS"))))))

t1.t2 <- all.tables2[c(38:39)]
t2.t3 <- all.tables2[c(39:40)]
t1.t3 <- all.tables2[c(38,40)]

t1.t2.sum <- t1.t2 %>% group_by(T1, T2) %>% summarise(count = n())
t1.t2.sum$T1 <- sub("^", "t1-", t1.t2.sum$T1)
t1.t2.sum$T2 <- sub("^", "t2-", t1.t2.sum$T2)
names(t1.t2.sum) <- c("source", "target", "value")

t2.t3.sum <- t2.t3 %>% group_by(T2, T3) %>% summarise(count = n())
t2.t3.sum$T2 <- sub("^", "t2-", t2.t3.sum$T2)
t2.t3.sum$T3 <- sub("^", "t3-", t2.t3.sum$T3)
names(t2.t3.sum) <- c("source", "target", "value")

t1.t3.sum <- t1.t3 %>% group_by(T1, T3) %>% summarise(count = n())
t1.t3.sum$T1 <- sub("^", "t1-", t1.t3.sum$T1)
t1.t3.sum$T3 <- sub("^", "t3-", t1.t3.sum$T3)
names(t1.t3.sum) <- c("source", "target", "value")

all.groups <- rbind(t1.t2.sum, t2.t3.sum)
nodes <- as.data.frame(unique(as.vector(rbind(all.groups$source, all.groups$target))))
names(nodes) <- "name"

all.groups$IDsource <- match(all.groups$source, nodes$name)-1 
all.groups$IDtarget <- match(all.groups$target, nodes$name)-1

p <- sankeyNetwork(Links = all.groups, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE)
p
```





https://jokergoo.github.io/2020/06/08/multiple-group-chord-diagram/

```{r fig.height=10, fig.width=10}
## set up storage matrix
# get names for row and columns
nameVals1 <- sort(unique(unlist(t1.t2.sum[1:2])))
# construct 0 matrix of correct dimensions with row and column names
mat1 <- matrix(0, length(nameVals1), length(nameVals1), dimnames = list(nameVals1, nameVals1))
# fill in the matrix with matrix indexing on row and column names
mat1[as.matrix(t1.t2.sum[c("source", "target")])] <- t1.t2.sum[["value"]]


nameVals2 <- sort(unique(unlist(t2.t3.sum[1:2])))
mat2 <- matrix(0, length(nameVals2), length(nameVals2), dimnames = list(nameVals2, nameVals2))
mat2[as.matrix(t2.t3.sum[c("source", "target")])] <- t2.t3.sum[["value"]]

nameVals3 <- sort(unique(unlist(t1.t3.sum[1:2])))
mat3 <- matrix(0, length(nameVals3), length(nameVals3), dimnames = list(nameVals3, nameVals3))
mat3[as.matrix(t1.t3.sum[c("source", "target")])] <- t1.t3.sum[["value"]]


mat.fin = matrix(0, nrow = 28, ncol = 28)
rownames(mat.fin) = c(rownames(mat2), rownames(mat3))
colnames(mat.fin) = c(colnames(mat1), colnames(mat2))
mat.fin[rownames(mat1), colnames(mat1)] = mat1
mat.fin[rownames(mat2), colnames(mat2)] = mat2
mat.fin[rownames(mat3), colnames(mat3)] = mat3
mat.fin

nm = unique(unlist(dimnames(mat.fin)))
group = structure(substr(nm, 1, 2), names = nm)
group

grid.col = structure(c(rep(2, 7), rep(3, 7), rep(4, 7)), names = c(paste0("t1", 1:7), paste0("t2", 1:7), paste0("t3", 1:7)))
chordDiagram(mat.fin, group = group, grid.col = grid.col)
```

```{r fig.height=10, fig.width=10}
nm = unique(unlist(dimnames(mat.fin)))
group = structure(substring(nm, 3), names = nm)
group

grid.col = structure(c(rep(2, 7), rep(3, 7), rep(4, 7)), names = c(paste0("t1", 1:7), paste0("t2", 1:7), paste0("t3", 1:7)))
chordDiagram(mat.fin, group = group, grid.col = grid.col)
```




```{r}
mat1 = matrix(rnorm(25), nrow = 5)
rownames(mat1) = paste0("A", 1:5)
colnames(mat1) = paste0("B", 1:5)

mat2 = matrix(rnorm(25), nrow = 5)
rownames(mat2) = paste0("A", 1:5)
colnames(mat2) = paste0("C", 1:5)

mat3 = matrix(rnorm(25), nrow = 5)
rownames(mat3) = paste0("B", 1:5)
colnames(mat3) = paste0("C", 1:5)

mat = matrix(0, nrow = 10, ncol = 10)
rownames(mat) = c(rownames(mat2), rownames(mat3))
colnames(mat) = c(colnames(mat1), colnames(mat2))
mat[rownames(mat1), colnames(mat1)] = mat1
mat[rownames(mat2), colnames(mat2)] = mat2
mat[rownames(mat3), colnames(mat3)] = mat3
mat
```

```{r}
nm = unique(unlist(dimnames(mat)))
group = structure(gsub("\\d", "", nm), names = nm)
group
```

```{r}
grid.col = structure(c(rep(2, 5), rep(3, 5), rep(4, 5)), names = c(paste0("A", 1:5), paste0("B", 1:5), paste0("C", 1:5)))
chordDiagram(mat, group = group, grid.col = grid.col)
```

```{r}
group = structure(gsub("^\\w", "", nm), names = nm)
group

chordDiagram(mat, group = group, grid.col = grid.col)
```



















# Gambusia pipeline

## Identifying differentially expressed genes by time points

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7873980/

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Subset data so analyses can be run on each time point separately
t1.samps <- coldata[which(coldata$time2 == "time1"),]
t1.n <- row.names(t1.samps)
t1 = data_keep[,which(colnames(data_keep) %in% t1.n)]
dim(t1)

t2.samps <- coldata[which(coldata$time2 == "time2"),]
t2.n <- row.names(t2.samps)
t2 = data_keep[,which(colnames(data_keep) %in% t2.n)]
dim(t2)

t3.samps <- coldata[which(coldata$time2 == "time3"),]
t3.n <- row.names(t3.samps)
t3 = data_keep[,which(colnames(data_keep) %in% t3.n)]
dim(t3)

# Group samples by temperature
temps.t1 = t1.samps$temp2
temps.t2 = t2.samps$temp2
temps.t3 = t3.samps$temp2

fam.t1 = t1.samps$rbs
fam.t2 = t2.samps$rbs
fam.t3 = t3.samps$rbs

# Generate data frame for each time with sample names and temperature
t1.samples = data.frame(cbind(colnames(t1)), as.character(temps.t1))
colnames(t1.samples) = c("tank","temp")

t2.samples = data.frame(cbind(colnames(t2)), as.character(temps.t2))
colnames(t2.samples) = c("tank","temp")

t3.samples = data.frame(cbind(colnames(t3)), as.character(temps.t3))
colnames(t3.samples) = c("tank","temp")

# Create a DGEList object to hold the dataset
t1.dge = DGEList(counts = t1, group = t1.samples$temp)
t2.dge = DGEList(counts = t2, group = t2.samples$temp)
t3.dge = DGEList(counts = t3, group = t3.samples$temp)

# Calculate normalized factors based on raw library sizes
t1.dge = calcNormFactors(t1.dge)
t2.dge = calcNormFactors(t2.dge)
t3.dge = calcNormFactors(t3.dge)

sample.design.t1 <- model.matrix(~0+temps.t1)
# Create a design matrix (because the datasets are already split in three by tissue, the only predictor is site)
sample.design.t1 <- model.matrix(~0+temps.t1 + fam.t1)
sample.design.t2 <- model.matrix(~0+temps.t2 + fam.t2)
sample.design.t3 <- model.matrix(~0+temps.t3 + fam.t3)

colnames(sample.design.t1) <- sub("temps.t1", "", colnames(sample.design.t1))
colnames(sample.design.t1) <- sub("fam.t1", "", colnames(sample.design.t1))

colnames(sample.design.t2) <- sub("temps.t2", "", colnames(sample.design.t2))
colnames(sample.design.t2) <- sub("fam.t2", "", colnames(sample.design.t2))

colnames(sample.design.t3) <- sub("temps.t3", "", colnames(sample.design.t3))
colnames(sample.design.t3) <- sub("fam.t3", "", colnames(sample.design.t3))


# Estimate common dispersion and tagwise dispersion
t1.dge <- estimateDisp(t1.dge, sample.design.t1)
t2.dge <- estimateDisp(t2.dge, sample.design.t2)
t3.dge <- estimateDisp(t3.dge, sample.design.t3)

# Given tagwise dispersion and a design matrix, glmFIT fits the negative binomial GLM for each tag. 
# Will then produce a DGEGLM object with new components. 
sample.fit.t1 <- glmFit(t1.dge, sample.design.t1)
sample.fit.t2 <- glmFit(t2.dge, sample.design.t2)
sample.fit.t3 <- glmFit(t3.dge, sample.design.t3)

# Construct contrast matrix of comparisons (compare populations in each tissue)
t1.contrast.20.18 <- makeContrasts(
  RBZ = temp20 - temp18,
  levels = sample.design.t1
  )
t1.contrast.20.16 <- makeContrasts(
  RBZ = temp20 - temp16,
  levels = sample.design.t1
  )

t2.contrast.20.18 <- makeContrasts(
  RBZ = temp20 - temp18,
  levels = sample.design.t2
  )
t2.contrast.20.16 <- makeContrasts(
  RBZ = temp20 - temp16,
  levels = sample.design.t2
  )

t3.contrast.20.18 <- makeContrasts(
  RBZ = temp20 - temp18,
  levels = sample.design.t3
  )
t3.contrast.20.16 <- makeContrasts(
  RBZ = temp20 - temp16,
  levels = sample.design.t3
  )

# Use the DGEGLM object to perform likelihood ratio test based on the contrast matrix of comparisons
t1_lrt_temp20.18 = glmLRT(sample.fit.t1, contrast = t1.contrast.20.18[,"RBZ"])
t1_lrt_temp20.16 = glmLRT(sample.fit.t1, contrast = t1.contrast.20.16[,"RBZ"])

t2_lrt_temp20.18 = glmLRT(sample.fit.t2, contrast = t2.contrast.20.18[,"RBZ"])
t2_lrt_temp20.16 = glmLRT(sample.fit.t2, contrast = t2.contrast.20.16[,"RBZ"])

t3_lrt_temp20.18 = glmLRT(sample.fit.t3, contrast = t3.contrast.20.18[,"RBZ"])
t3_lrt_temp20.16 = glmLRT(sample.fit.t3, contrast = t3.contrast.20.16[,"RBZ"])

```

## Number of DE genes in each comparison

```{r eval=FALSE, include=FALSE}
# Summary of differential expression that was up, down or not significant in each comparison
summary(decideTestsDGE(t1_lrt_temp20.18, adjust.method = "BH", p.value = 0.05))
summary(decideTestsDGE(t1_lrt_temp20.16, adjust.method = "BH", p.value = 0.05))

summary(decideTestsDGE(t2_lrt_temp20.18, adjust.method = "BH", p.value = 0.05))
summary(decideTestsDGE(t2_lrt_temp20.16, adjust.method = "BH", p.value = 0.05))

summary(decideTestsDGE(t3_lrt_temp20.18, adjust.method = "BH", p.value = 0.05))
summary(decideTestsDGE(t3_lrt_temp20.16, adjust.method = "BH", p.value = 0.05))

#WOOHOO; that' some cool shit
```

## Pulling out DE genes

```{r eval=FALSE, include=FALSE}
# Extract the results of the LRT for each gene to see which ones were differentially expressed. This can be found in the 
# "table" element from the lrt objects. We'll also need to add a column for FDR based on the p-value given
t1.18.table <- t1_lrt_temp20.18$table
t1.18.table$FDR <- p.adjust(t1.18.table$PValue, method = "BH")
t1.18.table$GeneID <- rownames(t1.18.table)
colnames(t1.18.table) <- paste("t1_18", colnames(t1.18.table), sep = "_")

t1.16.table <- t1_lrt_temp20.16$table
t1.16.table$FDR <- p.adjust(t1.16.table$PValue, method = "BH")
t1.16.table$GeneID <- rownames(t1.16.table)
colnames(t1.16.table) <- paste("t1_16", colnames(t1.16.table), sep = "_")


t2.18.table <- t2_lrt_temp20.18$table
t2.18.table$FDR <- p.adjust(t2.18.table$PValue, method = "BH")
t2.18.table$GeneID <- rownames(t2.18.table)
colnames(t2.18.table) <- paste("t2_18", colnames(t2.18.table), sep = "_")

t2.16.table <- t2_lrt_temp20.16$table
t2.16.table$FDR <- p.adjust(t2.16.table$PValue, method = "BH")
t2.16.table$GeneID <- rownames(t2.16.table)
colnames(t2.16.table) <- paste("t2_16", colnames(t2.16.table), sep = "_")


t3.18.table <- t3_lrt_temp20.18$table
t3.18.table$FDR <- p.adjust(t3.18.table$PValue, method = "BH")
t3.18.table$GeneID <- rownames(t3.18.table)
colnames(t3.18.table) <- paste("t3_18", colnames(t3.18.table), sep = "_")

t3.16.table <- t3_lrt_temp20.16$table
t3.16.table$FDR <- p.adjust(t3.16.table$PValue, method = "BH")
t3.16.table$GeneID <- rownames(t3.16.table)
colnames(t3.16.table) <- paste("t3_16", colnames(t3.16.table), sep = "_")

# Combine all the results tables above together into the same df
all.tables <- as.data.frame(cbind(t1.18.table, t1.16.table, t2.18.table, t2.16.table, t3.18.table, t3.16.table))

# Quality control: check to make sure all the rows are lined up correctly by checking if the GeneID columns all line up 
sum(which(all.tables$t1_18_GeneID != all.tables$t1_16_GeneID)) # should be zero if they match up
sum(which(all.tables$t1_18_GeneID != all.tables$t2_18_GeneID)) 
sum(which(all.tables$t1_18_GeneID != all.tables$t2_16_GeneID))
sum(which(all.tables$t1_18_GeneID != all.tables$t3_18_GeneID))
sum(which(all.tables$t1_18_GeneID != all.tables$t3_16_GeneID))

# Now let's add this table to the original df ######
composite.filtered <- as.data.frame(cbind(data_keep, all.tables))

# Extracting top tags for t1 and dividing into signficantly up- or downregulated
top_t1_20.18 = topTags(t1_lrt_temp20.18, n = (306 + 341))
top_t1_20.18.up = rownames(top_t1_20.18[top_t1_20.18$table$logFC > 0,])
top_t1_20.18.dn = rownames(top_t1_20.18[top_t1_20.18$table$logFC < 0,])

top_t1_20.16 = topTags(t1_lrt_temp20.16, n = (2365 + 2409))
top_t1_20.16.up = rownames(top_t1_20.16[top_t1_20.16$table$logFC > 0,])
top_t1_20.16.dn = rownames(top_t1_20.16[top_t1_20.16$table$logFC < 0,])

# Extracting top tags for t2 and dividing into signficantly up- or downregulated
top_t2_20.18 = topTags(t2_lrt_temp20.18, n = (274 + 126))
top_t2_20.18.up = rownames(top_t2_20.18[top_t2_20.18$table$logFC > 0,])
top_t2_20.18.dn = rownames(top_t2_20.18[top_t2_20.18$table$logFC < 0,])

top_t2_20.16 = topTags(t2_lrt_temp20.16, n = (699 + 1013))
top_t2_20.16.up = rownames(top_t2_20.16[top_t2_20.16$table$logFC > 0,])
top_t2_20.16.dn = rownames(top_t2_20.16[top_t2_20.16$table$logFC < 0,])

# Extracting top tags for t3 and dividing into signficantly up- or downregulated
top_t3_20.18 = topTags(t3_lrt_temp20.18, n = (190 + 83))
top_t3_20.18.up = rownames(top_t3_20.18[top_t3_20.18$table$logFC > 0,])
top_t3_20.18.dn = rownames(top_t3_20.18[top_t3_20.18$table$logFC < 0,])

top_t3_20.16 = topTags(t3_lrt_temp20.16, n = (7440 + 5544))
top_t3_20.16.up = rownames(top_t3_20.16[top_t3_20.16$table$logFC > 0,])
top_t3_20.16.dn = rownames(top_t3_20.16[top_t3_20.16$table$logFC < 0,])
```

## Venns

### Time 1

```{r eval=FALSE, include=FALSE}
# Upregulated candidate genes at t1
universal.t1.up <- unique(c(top_t1_20.18.up, top_t1_20.16.up))
t1.A.up <- universal.t1.up %in% top_t1_20.18.up
t1.B.up <- universal.t1.up %in% top_t1_20.16.up
universal.t1.up.input.df <- data.frame("temp18" = t1.A.up, "temp16" = t1.B.up)
head(universal.t1.up.input.df)
venn.t1.up.universal <- vennCounts(universal.t1.up.input.df)
vennDiagram(venn.t1.up.universal, main = "Upregulated Genes at Time 1", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t1.upreg <- universal.t1.up[which(universal.t1.up.input.df["temp18"] == T & universal.t1.up.input.df["temp16"] == T )]
common.t1.upreg <- data.frame(common.t1.upreg)
names(common.t1.upreg) <- "GeneID"
##########t1.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

```{r eval=FALSE, include=FALSE}
# Downregulated candidate genes at t1
universal.t1.dn <- unique(c(top_t1_20.18.dn, top_t1_20.16.dn))
t1.A.dn <- universal.t1.dn %in% top_t1_20.18.dn
t1.B.dn <- universal.t1.dn %in% top_t1_20.16.dn
universal.t1.dn.input.df <- data.frame("temp18" = t1.A.dn, "temp16" = t1.B.dn)
head(universal.t1.dn.input.df)
venn.t1.dn.universal <- vennCounts(universal.t1.dn.input.df)
vennDiagram(venn.t1.dn.universal, main = "Downregulated Genes at Time 1", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t1.dnreg <- universal.t1.dn[which(universal.t1.dn.input.df["temp18"] == T & universal.t1.dn.input.df["temp16"] == T )]
common.t1.dnreg <- data.frame(common.t1.dnreg)
names(common.t1.dnreg) <- "GeneID"
##########t1.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

### Time 2

```{r eval=FALSE, include=FALSE}
# Upregulated candidate genes at t2
universal.t2.up <- unique(c(top_t2_20.18.up, top_t2_20.16.up))
t2.A.up <- universal.t2.up %in% top_t2_20.18.up
t2.B.up <- universal.t2.up %in% top_t2_20.16.up
universal.t2.up.input.df <- data.frame("temp18" = t2.A.up, "temp16" = t2.B.up)
head(universal.t2.up.input.df)
venn.t2.up.universal <- vennCounts(universal.t2.up.input.df)
vennDiagram(venn.t2.up.universal, main = "Upregulated Genes at Time 2", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t2.upreg <- universal.t2.up[which(universal.t2.up.input.df["temp18"] == T & universal.t2.up.input.df["temp16"] == T )]
common.t2.upreg <- data.frame(common.t2.upreg)
names(common.t2.upreg) <- "GeneID"
##########t2.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

```{r eval=FALSE, include=FALSE}
# Downregulated candidate genes at t2
universal.t2.dn <- unique(c(top_t2_20.18.dn, top_t2_20.16.dn))
t2.A.dn <- universal.t2.dn %in% top_t2_20.18.dn
t2.B.dn <- universal.t2.dn %in% top_t2_20.16.dn
universal.t2.dn.input.df <- data.frame("temp18" = t2.A.dn, "temp16" = t2.B.dn)
head(universal.t2.dn.input.df)
venn.t2.dn.universal <- vennCounts(universal.t2.dn.input.df)
vennDiagram(venn.t2.dn.universal, main = "Downregulated Genes at Time 2", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t2.dnreg <- universal.t2.dn[which(universal.t2.dn.input.df["temp18"] == T & universal.t2.dn.input.df["temp16"] == T )]
common.t2.dnreg <- data.frame(common.t2.dnreg)
names(common.t2.dnreg) <- "GeneID"
##########t2.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

### Time 3

```{r eval=FALSE, include=FALSE}
# Upregulated candidate genes at t3
universal.t3.up <- unique(c(top_t3_20.18.up, top_t3_20.16.up))
t3.A.up <- universal.t3.up %in% top_t3_20.18.up
t3.B.up <- universal.t3.up %in% top_t3_20.16.up
universal.t3.up.input.df <- data.frame("temp18" = t3.A.up, "temp16" = t3.B.up)
head(universal.t3.up.input.df)
venn.t3.up.universal <- vennCounts(universal.t3.up.input.df)
vennDiagram(venn.t3.up.universal, main = "Upregulated Genes at Time 3", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t3.upreg <- universal.t3.up[which(universal.t3.up.input.df["temp18"] == T & universal.t3.up.input.df["temp16"] == T )]
common.t3.upreg <- data.frame(common.t3.upreg)
names(common.t3.upreg) <- "GeneID"
##########t3.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```

```{r eval=FALSE, include=FALSE}
# Downregulated candidate genes at t3
universal.t3.dn <- unique(c(top_t3_20.18.dn, top_t3_20.16.dn))
t3.A.dn <- universal.t3.dn %in% top_t3_20.18.dn
t3.B.dn <- universal.t3.dn %in% top_t3_20.16.dn
universal.t3.dn.input.df <- data.frame("temp18" = t3.A.dn, "temp16" = t3.B.dn)
head(universal.t3.dn.input.df)
venn.t3.dn.universal <- vennCounts(universal.t3.dn.input.df)
vennDiagram(venn.t3.dn.universal, main = "Downregulated Genes at Time 3", 
            names = c("Temp18", "Temp16"), cex = 1.5, cex.main = 1.5, 
            circle.col = c("turquoise","steelblue"), mar = c(0, 0, 1, 0))
common.t3.dnreg <- universal.t3.dn[which(universal.t3.dn.input.df["temp18"] == T & universal.t3.dn.input.df["temp16"] == T )]
common.t3.dnreg <- data.frame(common.t3.dnreg)
names(common.t3.dnreg) <- "GeneID"
##########t3.candidates.up <- merge(xmac.annotations[, c("XmacGene", "XmacGeneID", "Evalue", "HumanGene", "SwissprotAnnotationID")], common.gill.upreg, by = "XmacGene") # these are your candidate upregulated genes in the gill
```



